<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-08-11 Thu 12:21 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Eloquent JavaScript</title>
  <meta name="author" content="Toby Law">
  <meta name="generator" content="Org Mode">
  <link rel="stylesheet" href="res/tufte.min.css">
  <script async defer data-website-id=
  "da32127d-c6a3-438c-b385-e709c9d0e07d" src=
  "https://analytics.tzcl.me/umami.js"></script>
</head>
<body>
  <article id="content" class="content">
    <header>
      <h1 class="title">Eloquent JavaScript</h1>
      <p class="subtitle" role="doc-subtitle">Marijn Haverbeke</p>
    </header>
    <nav id="table-of-contents" role="doc-toc">
      <h2></h2>
      <div id="text-table-of-contents" role="doc-toc">
        <ul>
          <li>
            <a href="#org00a4a11">Review</a>
          </li>
          <li>
            <a href="#org2b3e660">Project 1: Path-finding robot</a>
          </li>
          <li>
            <a href="#org2852783">Project 2: Egg programming
            language</a>
          </li>
          <li>
            <a href="#orgbf32908">Project 3: Platformer game</a>
          </li>
          <li>
            <a href="#orge1a7f87">Exercise: Game of Life</a>
          </li>
          <li>
            <a href="#org6d74a05">Project 4: Pixel art editor</a>
          </li>
          <li>
            <a href="#orge7fa24b">Project 5: Skill-sharing
            website</a>
          </li>
        </ul>
      </div>
    </nav>
    <p><a href="index.html">← Back to blog</a></p>
    <section id="org00a4a11" class="nil">
      <h2 id="org00a4a11">Review</h2>
      <p><a href="https://eloquentjavascript.net/">Eloquent
      JavaScript</a> is a book that teaches you the fundamentals of
      programming through JavaScript. From my five minutes of
      research online, it seemed to the be popular beginner
      resource, with other recommendations being <a href=
      "https://javascript.info/">The Modern JavaScript
      Tutorial</a>, <a href=
      "https://www.amazon.com/JavaScript-Definitive-Most-Used-Programming-Language-dp-1491952024/dp/1491952024">
      JavaScript: The Definitive Guide</a> and the <a href=
      "https://github.com/getify/You-Dont-Know-JS">You Don’t Know
      JS Yet</a> book series.</p>
      <p>Overall, I really enjoyed the text and the exercises. The
      level of difficulty scales up pretty quickly so I wouldn’t
      recommend this book as a first introduction to programming
      but if you have learned another language it should be
      manageable. The projects were a lot of fun and satisfying to
      implement.</p>
      <p>JavaScript has an interesting history, given how it was
      rapidly hacked together by Brendan Eich and how the web has
      evolved since then. Some of the design decisions are
      questionable and very confusing as a beginner but actually
      make some sense once you understand them. Before reading
      Eloquent JavaScript, I was working my way through <a href=
      "https://mitpress.mit.edu/sites/default/files/sicp/index.html">
      SICP</a><label for="1" class=
      "margin-toggle sidenote-number"></label><input type=
      "checkbox" id="1" class="margin-toggle"><span class=
      "sidenote">One of the great classics of computer
      science</span> and you can really see the inspiration that
      JavaScript took from Scheme.</p>
      <p>Below are my solutions to the projects and the
      accompanying exercises from the text.</p>
    </section>
    <section id="org2b3e660" class="nil">
      <h2 id="org2b3e660">Project 1: Path-finding robot</h2>
      <p>The first project of the book is to build a mail-delivery
      robot that picks up and drops off parcels. Immediately, we
      are exposed to graphs and path-finding algorithms<label for=
      "2" class=
      "margin-toggle sidenote-number"></label><input type="checkbox"
      id="2" class="margin-toggle"><span class="sidenote">These are
      not the focus of the project but are cool to see</span>, and
      get to try solve an interesting problem.</p>
      <p><a href="./eloquentjs/robot/robot.html">Try out the robot
      here!</a></p>
      <h3 id="org117d8f6">Measuring a robot</h3>
      <p>To objectively compare robots, we want to make sure each
      time we generate a task, we give that task to both robots and
      track the result.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">compareRobots</span>(<span style=
      "color: #268bd2;">robot1</span>, <span style=
      "color: #268bd2;">memory1</span>, <span style=
      "color: #268bd2;">robot2</span>, <span style=
      "color: #268bd2;">memory2</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">steps1</span> = <span style=
"color: #6c71c4; font-weight: bold;">0</span>,
    steps2 = <span style=
"color: #6c71c4; font-weight: bold;">0</span>;
  <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">task</span> = <span style=
"color: #6c71c4; font-weight: bold;">0</span>; task &lt; <span style="color: #6c71c4; font-weight: bold;">100</span>; task++) {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">state</span> = VillageState.random();
    steps1 += countRobot(state, robot1, memory1);
    steps2 += countRobot(state, robot2, memory2);
  }

  console.log(<span style=
"color: #2aa198;">`robot1: ${steps1 / 100}, robot2: ${steps2 / 100}`</span>);
}
</code></pre>
      <h3 id="orgd84a8b2">Robot efficiency</h3>
      <p>The trick to designing a more efficient robot than the
      <code>goalOrientedRobot</code> is to realise that the
      <code>goalOrientedRobot</code> only looks at one parcel at a
      time. In some cases, the robot would be able to find a better
      route if it considered all parcels. This was fun to play
      around with, although I wished I could pause the animation to
      think about what I would do as my next move if I were the
      robot<label for="3" class=
      "margin-toggle sidenote-number"></label><input type=
      "checkbox" id="3" class="margin-toggle"><span class=
      "sidenote">I’ve built this into my version of the <a href=
      "./eloquentjs/robot/robot.html">robot
      animation</a></span>.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">greedyRobot</span>({ place, parcels }, route) {
  <span style=
"color: #859900; font-weight: bold;">if</span> (route.length == <span style="color: #6c71c4; font-weight: bold;">0</span>) {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">min_route</span> = [];

    <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">parcel</span> <span style=
"color: #859900; font-weight: bold;">of</span> parcels) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (parcel.place != place) {
        route = findRoute(roadGraph, place, parcel.place);
      } <span style=
"color: #859900; font-weight: bold;">else</span> {
        route = findRoute(roadGraph, place, parcel.address);
      }

      <span style=
"color: #859900; font-weight: bold;">if</span> (min_route.length == <span style="color: #6c71c4; font-weight: bold;">0</span> || route.length &lt; min_route.length) {
        min_route = route;
      }
    }

    route = min_route;
  }

  <span style=
"color: #859900; font-weight: bold;">return</span> { direction: route[<span style="color: #6c71c4; font-weight: bold;">0</span>], memory: route.slice(<span style="color: #6c71c4; font-weight: bold;">1</span>) };
}
</code></pre>
    </section>
    <section id="org2852783" class="nil">
      <h2 id="org2852783">Project 2: Egg programming language</h2>
      <p>In this project we build our own simple programming
      language called Egg:</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">do</span>(define(x, <span style="color: #6c71c4; font-weight: bold;">10</span>),
   <span style=
"color: #859900; font-weight: bold;">if</span>(&gt;(x, <span style=
"color: #6c71c4; font-weight: bold;">5</span>),
      print(<span style="color: #2aa198;">"large"</span>),
      print(<span style="color: #2aa198;">"small"</span>)))

# Console: large
</code></pre>
      <p>Egg is a tiny, simple language with a simple, uniform
      syntax. Everything in Egg is an expression. An expression can
      be a value, an identifier, or an application. Applications
      are what is applied to a function or a special form like
      <code>if</code> or <code>while</code>.</p>
      <p>Expressions of type “value” represent literal strings or
      numbers. Their <code>value</code> property contains the
      string or number value that they represent. Expressions of
      type “identifier” are used for names (variables or bindings).
      Such objects have a <code>name</code> property that holds the
      identifier’s name as a string. Finally, “apply” expressions
      represent applications. They have an <code>operator</code>
      property that refers to the expression that is being applied,
      as well as an <code>args</code> property that holds an array
      of argument expressions.</p>
      <p>The <code>&gt;(x, 5)</code> part of the previous program
      would be represented like this:</p>
      <pre class="code"><code>{
  type: <span style="color: #2aa198;">"apply"</span>,
  operator: {type: <span style=
"color: #2aa198;">"identifier"</span>, name: <span style=
"color: #2aa198;">"&gt;"</span>},
  args: [
    {type: <span style=
"color: #2aa198;">"identifier"</span>, name: <span style=
"color: #2aa198;">"x"</span>},
    {type: <span style=
"color: #2aa198;">"value"</span>, value: <span style=
"color: #6c71c4; font-weight: bold;">5</span>}
  ]
}
</code></pre>
      <p>To let us do interesting things in our language, we
      include a few special forms and useful bindings in the global
      scope:</p>
      <ul class="org-ul">
        <li>Special forms: <code>if</code>, <code>while</code>,
        <code>do</code> to do multiple things in one expression,
        <code>define</code> to create bindings, and
        <code>fun</code> to create functions</li>
        <li>Global scope: <code>true</code>, <code>false</code>,
        <code>+, -, *, /</code>, <code>print</code> to print to the
        console</li>
      </ul>
      <p><a href="./eloquentjs/egg/egg.html">Try out the Egg
      interpreter!</a></p>
      <h3 id="org1eaae3c">Arrays</h3>
      <p>We can implement arrays in Egg by adding the functions
      <code>array</code>, <code>length</code>, and
      <code>element</code> to the global scope. Respectively, they
      initialise an array, compute its length, and retrieve an
      element by index. Like with <code>if</code> and
      <code>while</code>, we cheat and use JavaScript’s arrays in
      our implementation.</p>
      <pre class=
      "code"><code>globalScope.array = (...values) =&gt; {
  <span style=
"color: #859900; font-weight: bold;">return</span> [...values];
};

globalScope.length = (array) =&gt; {
  <span style=
"color: #859900; font-weight: bold;">return</span> array.length;
};

globalScope.element = (array, n) =&gt; {
  <span style=
"color: #859900; font-weight: bold;">return</span> array[n];
};
</code></pre>
      <h3 id="orgda40371">Comments</h3>
      <p>Allowing comments in Egg is a matter of changing the
      parser so it skips the rest of the line when it encounters a
      <code>#</code>.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">skipSpace</span>(<span style=
      "color: #268bd2;">string</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">skippable</span> = string.match(<span style=
"color: #2aa198;">/^(\s|#.*)*/</span>);
  <span style=
"color: #859900; font-weight: bold;">return</span> string.slice(skippable[<span style="color: #6c71c4; font-weight: bold;">0</span>].length);
}
</code></pre>
      <h3 id="org94fc18f">Fixing scope</h3>
      <p>Assigning a new value to a binding with
      <code>define</code> can be counterintuitive because it may
      create a new binding in the local scope instead of updating
      the desired binding. We can get around this by adding the
      <code>set</code> function which will search for the binding
      in outer scopes.</p>
      <pre class=
      "code"><code>specialForms.set = (args, scope) =&gt; {
  <span style=
"color: #859900; font-weight: bold;">if</span> (args.length != <span style="color: #6c71c4; font-weight: bold;">2</span> || args[<span style="color: #6c71c4; font-weight: bold;">0</span>].type != <span style="color: #2aa198;">"identifier"</span>) {
    <span style=
"color: #859900; font-weight: bold;">throw</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">SyntaxError</span>(<span style="color: #2aa198;">"Incorrect use of set"</span>);
  }

  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">value</span> = evaluate(args[<span style=
"color: #6c71c4; font-weight: bold;">1</span>], scope);
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">name</span> = args[<span style=
"color: #6c71c4; font-weight: bold;">0</span>].name;

  <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">s</span> = scope; s; s = Object.getPrototypeOf(s)) {
    <span style=
"color: #859900; font-weight: bold;">if</span> (Object.<span style=
"color: #6c71c4; font-weight: bold;">prototype</span>.hasOwnProperty(s, name)) {
      s[name] = value;
      <span style=
"color: #859900; font-weight: bold;">return</span> value;
    }
  }

  <span style=
"color: #859900; font-weight: bold;">throw</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">ReferenceError</span>(<span style="color: #2aa198;">`Could not find ${name} in any scope.`</span>);
};
</code></pre>
    </section>
    <section id="orgbf32908" class="nil">
      <h2 id="orgbf32908">Project 3: Platformer game</h2>
      <p>This project uses the DOM as the rendering backend for a
      simple 2D platformer. Everything in the game is made of
      <code>div</code> elements with styling and positioning
      applied. You can actually get decent performance by adding
      and removing DOM elements, although working this way can feel
      a little clunky<label for="4" class=
      "margin-toggle sidenote-number"></label><input type=
      "checkbox" id="4" class="margin-toggle"><span class=
      "sidenote">A more idiomatic approach is to use the
      <code>&lt;canvas&gt;</code> element</span>.</p>
      <p><a href="./eloquentjs/platformer/platformer.html">Try out
      the platformer game here!</a></p>
      <h3 id="orgfd83714">Game over</h3>
      <p>We can keep track of the player’s lives by adding some
      logic to the function that starts the game.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">async</span> <span style=
      "color: #859900; font-weight: bold;">function</span> runGame(<span style="color: #268bd2;">plans</span>, <span style="color: #268bd2;">Display</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">lives</span> = <span style=
"color: #6c71c4; font-weight: bold;">3</span>;
  <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">level</span> = <span style=
"color: #6c71c4; font-weight: bold;">0</span>; level &lt; plans.length; ) {
    console.log(<span style=
"color: #2aa198;">`Lives: ${lives}`</span>);
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">status</span> = <span style=
"color: #859900; font-weight: bold;">await</span> runLevel(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Level</span>(plans[level]), Display);
    <span style=
"color: #859900; font-weight: bold;">if</span> (status == <span style="color: #2aa198;">"lost"</span>) {
      lives--;
      <span style=
"color: #859900; font-weight: bold;">if</span> (lives == <span style="color: #6c71c4; font-weight: bold;">0</span>) {
        console.log(<span style=
"color: #2aa198;">"You lost, restarting the game..."</span>);
        level = <span style=
"color: #6c71c4; font-weight: bold;">0</span>;
        lives = <span style=
"color: #6c71c4; font-weight: bold;">3</span>;
      }
    }
    <span style=
"color: #859900; font-weight: bold;">if</span> (status == <span style="color: #2aa198;">"won"</span>) level++;
  }
  console.log(<span style="color: #2aa198;">"You've won!"</span>);
}
</code></pre>
      <h3 id="orgc5f2a37">Pausing the game</h3>
      <p>Adding a way to pause/unpause the game is not immediately
      obvious since adding another key listener in the section
      where we listen to user input won’t work. The solution is to
      add the key listener for pausing higher up, putting that
      logic into the <code>runLevel</code> function.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">runLevel</span>(<span style=
      "color: #268bd2;">level</span>, <span style=
      "color: #268bd2;">Display</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">display</span> = <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Display</span>(document.body, level);
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">state</span> = State.start(level);
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">ending</span> = <span style=
"color: #6c71c4; font-weight: bold;">1</span>;
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">running</span> = <span style=
"color: #2aa198;">"yes"</span>;

  <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Promise</span>((resolve) =&gt; {
    <span style=
"color: #859900; font-weight: bold;">function</span> <span style=
"color: #b58900;">escHandler</span>(<span style=
"color: #268bd2;">event</span>) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (event.key != <span style="color: #2aa198;">"Escape"</span>) <span style="color: #859900; font-weight: bold;">return</span>;
      event.preventDefault();
      <span style=
"color: #859900; font-weight: bold;">if</span> (running == <span style="color: #2aa198;">"no"</span>) {
        console.log(<span style=
"color: #2aa198;">"Unpausing game"</span>);
        running = <span style="color: #2aa198;">"yes"</span>;
        runAnimation(frame);
      } <span style=
"color: #859900; font-weight: bold;">else</span> <span style=
"color: #859900; font-weight: bold;">if</span> (running == <span style="color: #2aa198;">"yes"</span>) {
        console.log(<span style=
"color: #2aa198;">"Pausing game"</span>);
        running = <span style="color: #2aa198;">"pausing"</span>;
      } <span style=
"color: #859900; font-weight: bold;">else</span> {
        running = <span style="color: #2aa198;">"yes"</span>;
      }
    }

    window.addEventListener(<span style=
"color: #2aa198;">"keyup"</span>, escHandler);

    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">keys</span> = trackKeys([<span style=
"color: #2aa198;">"ArrowLeft"</span>, <span style=
"color: #2aa198;">"ArrowRight"</span>, <span style=
"color: #2aa198;">"ArrowUp"</span>, <span style=
"color: #2aa198;">"a"</span>, <span style=
"color: #2aa198;">"d"</span>, <span style=
"color: #2aa198;">"w"</span>]);

    <span style=
"color: #859900; font-weight: bold;">function</span> <span style=
"color: #b58900;">frame</span>(<span style=
"color: #268bd2;">time</span>) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (running == <span style="color: #2aa198;">"pausing"</span>) {
        console.log(<span style=
"color: #2aa198;">"Game paused"</span>);
        running = <span style="color: #2aa198;">"no"</span>;
        <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #6c71c4; font-weight: bold;">false</span>;
      }

      state = state.update(time, keys);
      display.syncState(state);
      <span style=
"color: #859900; font-weight: bold;">if</span> (state.status == <span style="color: #2aa198;">"playing"</span>) {
        <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #6c71c4; font-weight: bold;">true</span>;
      } <span style=
"color: #859900; font-weight: bold;">else</span> <span style=
"color: #859900; font-weight: bold;">if</span> (ending &gt; <span style="color: #6c71c4; font-weight: bold;">0</span>) {
        ending -= time;
        <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #6c71c4; font-weight: bold;">true</span>;
      } <span style=
"color: #859900; font-weight: bold;">else</span> {
        display.clear();
        window.removeEventListener(<span style=
"color: #2aa198;">"keyup"</span>, escHandler);
        keys.unregister();
        resolve(state.status);
        <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #6c71c4; font-weight: bold;">false</span>;
      }
    }

    runAnimation(frame);
  });
}
</code></pre>
      <h3 id="org9d0db80">A monster</h3>
      <p>Using the scaffolding we’ve set up for the player, adding
      an enemy isn’t too hard. The tricky part is determining
      whether the player jumped on the head of the monster. The
      simplest way to approach is to compare the y-coords of the
      player and the monster at the time of collision.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">class</span> Monster {
  constructor(pos, speed) {
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.pos = pos;
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.speed = speed;
  }

  update(time, state) {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">newPos</span> = <span style=
"color: #6c71c4; font-weight: bold;">this</span>.pos.plus(<span style="color: #6c71c4; font-weight: bold;">this</span>.speed.times(time));
    <span style=
"color: #859900; font-weight: bold;">if</span> (!state.level.touches(newPos, <span style="color: #6c71c4; font-weight: bold;">this</span>.size, <span style="color: #2aa198;">"wall"</span>)) {
      <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Monster</span>(newPos, <span style="color: #6c71c4; font-weight: bold;">this</span>.speed);
    } <span style=
"color: #859900; font-weight: bold;">else</span> {
      <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Monster</span>(<span style=
"color: #6c71c4; font-weight: bold;">this</span>.pos, <span style=
"color: #6c71c4; font-weight: bold;">this</span>.speed.times(-<span style="color: #6c71c4; font-weight: bold;">1</span>));
    }
  }

  collide(state) {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">player</span> = state.player;
    <span style=
"color: #859900; font-weight: bold;">if</span> (player.pos.y &lt; <span style="color: #6c71c4; font-weight: bold;">this</span>.pos.y) {
      <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">filtered</span> = state.actors.filter((a) =&gt; a != <span style="color: #6c71c4; font-weight: bold;">this</span>);
      <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">State</span>(state.level, filtered, <span style="color: #2aa198;">"playing"</span>);
    }

    <span style=
"color: #859900; font-weight: bold;">return</span> state;
  }

  get type() {
    <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #2aa198;">"monster"</span>;
  }

  get size() {
    <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Vec</span>(<span style=
"color: #6c71c4; font-weight: bold;">1.2</span>, <span style=
"color: #6c71c4; font-weight: bold;">2</span>);
  }

  <span style=
"color: #859900; font-weight: bold;">static</span> create(pos) {
    <span style=
"color: #859900; font-weight: bold;">return</span> <span style=
"color: #859900; font-weight: bold;">new</span> <span style=
"color: #b58900; font-style: italic;">Monster</span>(pos.plus(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Vec</span>(<span style="color: #6c71c4; font-weight: bold;">0</span>, -<span style="color: #6c71c4; font-weight: bold;">1</span>)), <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Vec</span>(<span style="color: #6c71c4; font-weight: bold;">2</span>, <span style="color: #6c71c4; font-weight: bold;">0</span>));
  }
}
</code></pre>
    </section>
    <section id="orge1a7f87" class="nil">
      <h2 id="orge1a7f87">Exercise: Game of Life</h2>
      <p>Using HTML forms, it’s possible to write a basic version
      of the Game of Life. Each generation, a checkbox transitions
      according to the following rules:</p>
      <ol class="org-ol">
        <li>Underpopulation: any checked checkbox with less than
        two checked neighbours becomes unchecked</li>
        <li>Survival: any checked checkbox with two or three
        neighbours stays checked in the next generation</li>
        <li>Overpopulation: any checked checkbox with more than
        three checked neighbours becomes unchecked</li>
        <li>Reproduction: any unchecked checkbox with exactly three
        neighbours becomes checked</li>
      </ol>
      <p>Technically, the Game of Life is meant to be played on an
      infinite grid. There are a few ways to address this, such as
      wrapping cells around to the other side of the grid in case
      they go off screen. However, I didn’t bother with this – try
      to imagine there is a sea of dead cells around the grid.</p>
      <p><a href="./eloquentjs/game-of-life/game-of-life.html">Try
      out the Game of Life!</a></p>
    </section>
    <section id="org6d74a05" class="nil">
      <h2 id="org6d74a05">Project 4: Pixel art editor</h2>
      <p>As discussed in the platformer project, another way to
      render graphics on the web is using
      <code>&lt;canvas&gt;</code> elements. The design of this
      application is the first time we use components, which
      logically distribute state throughout the interface. Properly
      dealing with the flow of data is important to avoid ending up
      with spaghetti code. An interesting problem was adding event
      listeners to work both with mouse events and touch events,
      each of which work slightly differently.</p>
      <p><a href="./eloquentjs/pixel-art/pixel-art.html">Try out
      the pixel art editor!</a></p>
      <h3 id="orgba036b8">Keyboard bindings</h3>
      <p>We want to add keyboard shortcuts such that pressing
      <code>ctrl-</code> or <code>cmd-</code> and the first letter
      of the tool automatically switches to that tool. Fortunately,
      the way we’ve designed the app makes this easy to do – we
      just need to add an event listener that dispatches on the
      different keybindings.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">class</span> PixelEditor {
  constructor(state, config) {
    <span style=
"color: #859900; font-weight: bold;">let</span> { tools, controls, dispatch } = config;
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.state = state;

    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.canvas = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">PictureCanvas</span>(
      state.picture,
      (pos) =&gt; {
        <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">tool</span> = tools[<span style=
"color: #6c71c4; font-weight: bold;">this</span>.state.tool];

        <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">Call the tool once</span>
        <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">onMove</span> = tool(pos, <span style=
"color: #6c71c4; font-weight: bold;">this</span>.state, dispatch);
        <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">Pass along function in case we need to redraw</span>
        <span style=
"color: #859900; font-weight: bold;">if</span> (onMove) <span style="color: #859900; font-weight: bold;">return</span> (pos) =&gt; onMove(pos, <span style="color: #6c71c4; font-weight: bold;">this</span>.state);
      },
      () =&gt; dispatch({ commit: <span style=
"color: #6c71c4; font-weight: bold;">true</span> })
    );

    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.controls = controls.map((Control) =&gt; <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Control</span>(state, config));

    <span style=
"color: #859900; font-weight: bold;">const</span> <span style=
"color: #268bd2;">keyDown</span> = (event) =&gt; {
      <span style=
"color: #859900; font-weight: bold;">if</span> (event.key == <span style="color: #2aa198;">"z"</span> &amp;& (event.ctrlKey || event.metaKey)) {
        dispatch({ revert: <span style=
"color: #2aa198;">"undo"</span> });
      } <span style=
"color: #859900; font-weight: bold;">else</span> <span style=
"color: #859900; font-weight: bold;">if</span> (event.key == <span style="color: #2aa198;">"y"</span> &amp;& (event.ctrlKey || event.metaKey)) {
        dispatch({ revert: <span style=
"color: #2aa198;">"redo"</span> });
      } <span style=
"color: #859900; font-weight: bold;">else</span> <span style=
"color: #859900; font-weight: bold;">if</span> (!event.ctrlKey &amp;& !event.metaKey &amp;& !event.altKey) {
        <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">tool</span> <span style=
"color: #859900; font-weight: bold;">in</span> tools) {
          <span style=
"color: #859900; font-weight: bold;">if</span> (event.key == tool[<span style="color: #6c71c4; font-weight: bold;">0</span>]) {
            dispatch({ tool });
            <span style=
"color: #859900; font-weight: bold;">return</span>;
          }
        }
      }
    };

    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.dom = elt(
      <span style="color: #2aa198;">"div"</span>,
      { tabIndex: <span style=
"color: #6c71c4; font-weight: bold;">0</span>, onkeydown: (event) =&gt; keyDown(event) },
      <span style=
"color: #6c71c4; font-weight: bold;">this</span>.canvas.dom,
      elt(<span style="color: #2aa198;">"br"</span>),
      ...<span style=
"color: #6c71c4; font-weight: bold;">this</span>.controls.reduce((a, c) =&gt; a.concat(<span style="color: #2aa198;">" "</span>, c.dom), [])
    );
  }
  ...
}
</code></pre>
      <h3 id="org4d720b8">Efficient drawing</h3>
      <p>At the moment, each time we create a new state, we are
      redrawing all the pixels on the canvas which can be
      expensive. One way we can optimise this is to keep track of
      the previous state and then ’diff’ that against the new state
      and only draw the pixels that change.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">patchPicture</span>(<span style=
      "color: #268bd2;">prev</span>, <span style=
      "color: #268bd2;">curr</span>, <span style=
      "color: #268bd2;">canvas</span>, <span style=
      "color: #268bd2;">scale</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">cx</span> = canvas.getContext(<span style=
"color: #2aa198;">"2d"</span>);

  <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">y</span> = <span style=
"color: #6c71c4; font-weight: bold;">0</span>; y &lt; prev.height; y++) {
    <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">x</span> = <span style=
"color: #6c71c4; font-weight: bold;">0</span>; x &lt; prev.width; x++) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (prev.pixel(x, y) != curr.pixel(x, y)) {
        cx.fillStyle = curr.pixel(x, y);
        cx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
  }
}
</code></pre>
      <h3 id="org860d2fc">Circles</h3>
      <p>Figuring out how to draw circles was a lot of fun. I
      struggled for a bit getting circles which were mostly squares
      with individual pixels sticking out (that looked like
      nipples) but managed to fix this by taking the
      <code>ceil</code> of the distance when I was computing the
      radius. Below is what I found to give the best looking
      circles.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">circle</span>(<span style=
      "color: #268bd2;">start</span>, <span style=
      "color: #268bd2;">state</span>, <span style=
      "color: #268bd2;">dispatch</span>) {
  <span style=
"color: #859900; font-weight: bold;">const</span> <span style=
"color: #268bd2;">dist</span> = (x, y) =&gt; {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">dx</span> = x - start.x;
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">dy</span> = y - start.y;
    <span style=
"color: #859900; font-weight: bold;">return</span> Math.sqrt(dx * dx + dy * dy);
  };

  <span style=
"color: #859900; font-weight: bold;">function</span> <span style=
"color: #b58900;">drawCircle</span>(<span style=
"color: #268bd2;">pos</span>) {
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">radius</span> = Math.ceil(dist(pos.x, pos.y));

    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">xStart</span> = Math.max(<span style=
"color: #6c71c4; font-weight: bold;">0</span>, start.x - radius);
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">yStart</span> = Math.max(<span style=
"color: #6c71c4; font-weight: bold;">0</span>, start.y - radius);
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">xEnd</span> = Math.min(start.x + radius, state.picture.width);
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">yEnd</span> = Math.min(start.y + radius, state.picture.height);

    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">drawn</span> = [];
    <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">y</span> = yStart; y &lt;= yEnd; y++) {
      <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">x</span> = xStart; x &lt;= xEnd; x++) {
        <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">d</span> = dist(x, y);
        <span style=
"color: #859900; font-weight: bold;">if</span> (d &lt; radius) drawn.push({ x, y, colour: state.colour });
      }
    }

    dispatch({ picture: state.picture.draw(drawn) });
  }

  drawCircle(start);
  <span style=
"color: #859900; font-weight: bold;">return</span> drawCircle;
}
</code></pre>
      <h3 id="org662d02f">Proper lines</h3>
      <p>This was much more difficult than the previous exercises.
      I’ve heard of <a href=
      "https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham’s
      line algorithm</a> before and that seemed to be what was
      needed. Generalising the algorithm to work for all octants
      took some time but it was satisfying being able to draw quick
      lines without gaps.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">function</span> <span style=
      "color: #b58900;">drawLine</span>(<span style=
      "color: #268bd2;">start</span>, <span style=
      "color: #268bd2;">pos</span>, <span style=
      "color: #268bd2;">colour</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">dx</span> = Math.abs(pos.x - start.x);
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">sx</span> = start.x &lt; pos.x ? <span style=
"color: #6c71c4; font-weight: bold;">1</span> : -<span style=
"color: #6c71c4; font-weight: bold;">1</span>;

  <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">Note the negative</span>
  <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">In graphics, y++ means moving down</span>
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">dy</span> = -Math.abs(pos.y - start.y);
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">sy</span> = start.y &lt; pos.y ? <span style=
"color: #6c71c4; font-weight: bold;">1</span> : -<span style=
"color: #6c71c4; font-weight: bold;">1</span>;

  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">err</span> = dx + dy;

  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">drawn</span> = [];
  <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">x</span> = start.x, <span style=
"color: #268bd2;">y</span> = start.y; ; ) {
    drawn.push({ x, y, colour });
    <span style=
"color: #859900; font-weight: bold;">if</span> (x == pos.x &amp;& y == pos.y) <span style="color: #859900; font-weight: bold;">break</span>;
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">err2</span> = <span style=
"color: #6c71c4; font-weight: bold;">2</span> * err; <span style=
"color: #96A7A9;">// </span><span style=
"color: #96A7A9;">avoid dividing</span>
    <span style=
"color: #859900; font-weight: bold;">if</span> (err2 &gt;= dy) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (x == pos.x) <span style="color: #859900; font-weight: bold;">break</span>;
      err += dy;
      x += sx;
    }
    <span style=
"color: #859900; font-weight: bold;">if</span> (err2 &lt;= dx) {
      <span style=
"color: #859900; font-weight: bold;">if</span> (y == pos.y) <span style="color: #859900; font-weight: bold;">break</span>;
      err += dx;
      y += sy;
    }
  }

  <span style=
"color: #859900; font-weight: bold;">return</span> drawn;
}
</code></pre>
    </section>
    <section id="orge7fa24b" class="nil">
      <h2 id="orge7fa24b">Project 5: Skill-sharing website</h2>
      <p>This project was most like a real web app. In short, it
      allows users to add talks (for some kind of meetup) and
      comments on those talks. Using long-polling, it was possible
      to have the client update whenever any changes occurred on
      the server. To summarise, long polling is where clients
      continually ask the server for new information using regular
      HTTP requests, and the server delays its answer until it an
      update. The trick is to always have a polling request open
      and to set a long maximum time for each request to avoid
      timing out. Node made this easy to manage on the server
      side.</p>
      <h3 id="org3557572">Disk persistence</h3>
      <p>The simplest way we can add disk persistence is to make
      our <code>update</code> function write any changes to a
      file.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">class</span> SkillShareServer {
  updated() {
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.version++;
    <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">res</span> = <span style=
"color: #6c71c4; font-weight: bold;">this</span>.talkResponse();
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.waiting.forEach((resolve) =&gt; resolve(res));
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.waiting = [];

    writeFile(filePath, JSON.stringify(<span style=
"color: #6c71c4; font-weight: bold;">this</span>.talks), (err) =&gt; {
      <span style=
"color: #859900; font-weight: bold;">if</span> (err) <span style=
"color: #859900; font-weight: bold;">throw</span> err;
    });
  }
  ...
}
</code></pre>
      <p>Then, when we launch the server, we want it to read in any
      talks from disk, if they exist. We pass this to the
      <code>SkillShareServer</code> through its constructor.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">const</span> <span style=
      "color: #268bd2;">filePath</span> = <span style=
      "color: #2aa198;">"data.json"</span>;

<span style=
"color: #859900; font-weight: bold;">async</span> <span style=
"color: #859900; font-weight: bold;">function</span> loadTalks(<span style="color: #268bd2;">file</span> = <span style="color: #268bd2;">filePath</span>) {
  <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">data</span>;
  <span style="color: #859900; font-weight: bold;">try</span> {
    data = JSON.parse(<span style=
"color: #859900; font-weight: bold;">await</span> readFile(file, { encoding: <span style="color: #2aa198;">"utf-8"</span> }));
  } <span style=
"color: #859900; font-weight: bold;">catch</span> (err) {
    data = {};
  }

  <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">Need to do this to remove the prototype</span>
  <span style="color: #96A7A9;">// </span><span style=
"color: #96A7A9;">If not, we wouldn't be able to use the 'in' operator safely</span>
  <span style=
"color: #859900; font-weight: bold;">return</span> Object.assign(Object.create(<span style="color: #6c71c4; font-weight: bold;">null</span>), data);
}
</code></pre>
      <h3 id="org473aa9f">Comment field resets</h3>
      <p>One issue with how we’ve built the app is that it replaces
      DOM elements each time it renders. This may be annoying if
      you start writing a comment, and then someone else posts
      something, leading to the app replacing the comment box and
      losing its content.</p>
      <p>The simplest way to fix this is to keep track of comments
      as part of state and using that to fill in the content when
      the view updates.</p>
      <pre class="code"><code><span style=
      "color: #859900; font-weight: bold;">class</span> Talk {
  constructor(talk, dispatch) {
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.comments = elt(<span style="color: #2aa198;">"div"</span>);
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.dom = elt(
      <span style="color: #2aa198;">"section"</span>,
      { className: <span style="color: #2aa198;">"talk"</span> },
      elt(
        <span style="color: #2aa198;">"h2"</span>,
        <span style=
"color: #6c71c4; font-weight: bold;">null</span>,
        talk.title,
        <span style="color: #2aa198;">" "</span>,
        elt(
          <span style="color: #2aa198;">"button"</span>,
          {
            type: <span style="color: #2aa198;">"button"</span>,
            onclick() {
              dispatch({ type: <span style=
"color: #2aa198;">"deleteTalk"</span>, talk: talk.title });
            },
          },
          <span style="color: #2aa198;">"Delete"</span>
        )
      ),
      elt(<span style="color: #2aa198;">"div"</span>, <span style=
"color: #6c71c4; font-weight: bold;">null</span>, <span style=
"color: #2aa198;">"by "</span>, elt(<span style=
"color: #2aa198;">"strong"</span>, <span style=
"color: #6c71c4; font-weight: bold;">null</span>, talk.presenter)),
      elt(<span style="color: #2aa198;">"p"</span>, <span style=
"color: #6c71c4; font-weight: bold;">null</span>, talk.summary),
      <span style=
"color: #6c71c4; font-weight: bold;">this</span>.comments,
      elt(
        <span style="color: #2aa198;">"form"</span>,
        {
          onsubmit(e) {
            e.preventDefault();
            <span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">form</span> = e.target;
            dispatch({
              type: <span style=
"color: #2aa198;">"newComment"</span>,
              talk: talk.title,
              message: form.elements.comment.value,
            });
            form.reset();
          },
        },
        elt(<span style=
"color: #2aa198;">"input"</span>, { type: <span style=
"color: #2aa198;">"text"</span>, name: <span style=
"color: #2aa198;">"comment"</span> }),
        <span style="color: #2aa198;">" "</span>,
        elt(<span style=
"color: #2aa198;">"button"</span>, { type: <span style=
"color: #2aa198;">"submit"</span> }, <span style=
"color: #2aa198;">"Add comment"</span>)
      )
    );
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.syncState(talk);
  }

  syncState(talk) {
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.talk = talk;
    <span style=
"color: #6c71c4; font-weight: bold;">this</span>.comments.textContent = <span style="color: #2aa198;">""</span>;
    <span style=
"color: #859900; font-weight: bold;">for</span> (<span style=
"color: #859900; font-weight: bold;">let</span> <span style=
"color: #268bd2;">comment</span> <span style=
"color: #859900; font-weight: bold;">of</span> talk.comments) {
      <span style=
"color: #6c71c4; font-weight: bold;">this</span>.comments.appendChild(renderComment(comment));
    }
  }
}

<span style=
"color: #859900; font-weight: bold;">function</span> <span style=
"color: #b58900;">renderComment</span>(<span style=
"color: #268bd2;">comment</span>) {
  <span style=
"color: #859900; font-weight: bold;">return</span> elt(
    <span style="color: #2aa198;">"p"</span>,
    { className: <span style="color: #2aa198;">"comment"</span> },
    elt(<span style="color: #2aa198;">"strong"</span>, <span style=
"color: #6c71c4; font-weight: bold;">null</span>, comment.author),
    <span style="color: #2aa198;">": "</span>,
    comment.message
  );
}
</code></pre>
    </section><!-- Footnotes --><!-- 
<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">One of the great classics of computer science</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">These are not the focus of the project but are cool to see</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">I&rsquo;ve built this into my version of the <a href="./eloquentjs/robot/robot.html">robot animation</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">A more idiomatic approach is to use the <code>&lt;canvas&gt;</code>  element</p></div></div>

 -->
  </article>
</body>
</html>
