#+TITLE: Eloquent JavaScript
#+SUBTITLE: Marijn Haverbeke
#+OPTIONS: toc:1

* Review

[[https://eloquentjavascript.net/][Eloquent JavaScript]] is a book that teaches you the fundamentals of programming through JavaScript. From a cursory glance online it was the most recommended book I could find, with other popular suggestions being [[https://javascript.info/][The Modern JavaScript Tutorial]], [[https://www.amazon.com/JavaScript-Definitive-Most-Used-Programming-Language-dp-1491952024/dp/1491952024][JavaScript: The Definitive Guide]] and the [[https://github.com/getify/You-Dont-Know-JS][You Don't Know JS Yet]] book series.

Overall, I really enjoyed the text and the exercises. The level of difficulty scales up pretty quickly so I wouldn't recommend this book as a first introduction to programming but if you have learned another language it should be manageable. The projects were a lot of fun and satisfying to implement.

JavaScript has an interesting history, given how it was rapidly hacked together by Brendan Eich and how the web has evolved since then. Some of the design decisions are questionable and very confusing as a beginner but I think I am more tolerant of them than most. Before reading Eloquent JavaScript, I was working my way through [[https://mitpress.mit.edu/sites/default/files/sicp/index.html][SICP]][fn:: One of the great classics of computer science] and you can really see the inspiration that JavaScript took from Scheme.

Below are my solutions to the projects and the accompanying exercises from the text.

* Project 1: Path-finding robot
The first project of the book is to build a mail-delivery robot that picks up and drops off parcels. Immediately, we are exposed to graphs and path-finding algorithms[fn:: These are not the focus of the project but are cool to see], and get to try solve an interesting problem.

#+begin_export html
<div id="pathfinding"></div>
#+end_export
<script src="../eloquentjs/robot.js"></script>

** Measuring a robot
** Robot efficiency
** Persistent group
* Project 2: Egg programming language
In this project we build our own simple programming language called Egg:
#+begin_src js
do(define(x, 10),
   if(>(x, 5),
      print("large"),
      print("small")))

# Console: large
#+end_src

Egg is a tiny, simple language with a simple, uniform syntax. Everything in Egg is an expression. An expression can be a value, an identifier, or an application. Applications are what is applied to a function or a special form like =if= or =while=.

Expressions of type "value" represent literal strings or numbers. Their =value= property contains the string or number value that they represent. Expressions of type "identifier" are used for names (variables or bindings). Such objects have a =name= property that holds the identifierâ€™s name as a string. Finally, "apply" expressions represent applications. They have an =operator= property that refers to the expression that is being applied, as well as an =args= property that holds an array of argument expressions.

The ~>(x, 5)~ part of the previous program would be represented like this:
#+begin_src js
{
  type: "apply",
  operator: {type: "identifier", name: ">"},
  args: [
    {type: "identifier", name: "x"},
    {type: "value", value: 5}
  ]
}
#+end_src

To let us do interesting things in our language, we include a few special forms and useful bindings in the global scope:
+ Special forms: =if=, =while=, =do= to do multiple things in one expression, =define= to create bindings, and =fun= to create functions
+ Global scope: =true=, =false=, =+, -, *, /=, =print= to print to the console

[[./eloquentjs/egg.html][Try out the Egg interpreter!]]

** Arrays
We can implement arrays in Egg by adding the functions =array=, =length=, and =element= to the global scope. Respectively, they initialise an array, compute its length, and retrieve an element by index. Like with =if= and =while=, we cheat and use JavaScript's arrays in our implementation.
#+begin_src js
globalScope.array = (...values) => {
  return [...values];
};

globalScope.length = (array) => {
  return array.length;
};

globalScope.element = (array, n) => {
  return array[n];
};
#+end_src

** Comments
Allowing comments in Egg is a matter of changing the parser so it skips the rest of the line when it encounters a =#=.
#+begin_src js
function skipSpace(string) {
  let skippable = string.match(/^(\s|#.*)*/);
  return string.slice(skippable[0].length);
}
#+end_src

** Fixing scope
Assigning a new value to a binding with =define= can be counterintuitive because it may create a new binding in the local scope instead of updating the desired binding. We can get around this by adding the =set= function which will search for the binding in outer scopes.
#+begin_src js
specialForms.set = (args, scope) => {
  if (args.length != 2 || args[0].type != "identifier") {
    throw new SyntaxError("Incorrect use of set");
  }

  let value = evaluate(args[1], scope);
  let name = args[0].name;

  for (let s = scope; s; s = Object.getPrototypeOf(s)) {
    if (Object.prototype.hasOwnProperty(s, name)) {
      s[name] = value;
      return value;
    }
  }

  throw new ReferenceError(`Could not find ${name} in any scope.`);
};
#+end_src

* Project 3: Platformer game
* Side project: Game of Life
* Project 4: Pixel art editor
* Project 5: Skill-sharing website
