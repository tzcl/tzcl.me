#+TITLE: Eloquent JavaScript
#+SUBTITLE: Marijn Haverbeke
#+OPTIONS: toc:1

[[file:index.org][← Back to blog]]

* Review

[[https://eloquentjavascript.net/][Eloquent JavaScript]] is a book that teaches you the fundamentals of programming through JavaScript. From a cursory glance online, it seemed to the be the most recommended, with other popular suggestions being [[https://javascript.info/][The Modern JavaScript Tutorial]], [[https://www.amazon.com/JavaScript-Definitive-Most-Used-Programming-Language-dp-1491952024/dp/1491952024][JavaScript: The Definitive Guide]] and the [[https://github.com/getify/You-Dont-Know-JS][You Don't Know JS Yet]] book series.

Overall, I really enjoyed the text and the exercises. The level of difficulty scales up pretty quickly so I wouldn't recommend this book as a first introduction to programming but if you have learned another language it should be manageable. The projects were a lot of fun and satisfying to implement.

JavaScript has an interesting history, given how it was rapidly hacked together by Brendan Eich and how the web has evolved since then. Some of the design decisions are questionable and very confusing as a beginner but actually make some sense once you understand them. Before reading Eloquent JavaScript, I was working my way through [[https://mitpress.mit.edu/sites/default/files/sicp/index.html][SICP]][fn::One of the great classics of computer science] and you can really see the inspiration that JavaScript took from Scheme.

Below are my solutions to the projects and the accompanying exercises from the text.

* Project 1: Path-finding robot
The first project of the book is to build a mail-delivery robot that picks up and drops off parcels. Immediately, we are exposed to graphs and path-finding algorithms[fn:: These are not the focus of the project but are cool to see], and get to try solve an interesting problem.

[[./eloquentjs/robot/robot.html][Try out the robot here!]]

I need to keep going at this, stuck on implementing controls. Need to do some thinking on how to organise this all.

** Measuring a robot
** Robot efficiency

* Project 2: Egg programming language
In this project we build our own simple programming language called Egg:
#+begin_src js
do(define(x, 10),
   if(>(x, 5),
      print("large"),
      print("small")))

# Console: large
#+end_src

Egg is a tiny, simple language with a simple, uniform syntax. Everything in Egg is an expression. An expression can be a value, an identifier, or an application. Applications are what is applied to a function or a special form like =if= or =while=.

Expressions of type "value" represent literal strings or numbers. Their =value= property contains the string or number value that they represent. Expressions of type "identifier" are used for names (variables or bindings). Such objects have a =name= property that holds the identifier’s name as a string. Finally, "apply" expressions represent applications. They have an =operator= property that refers to the expression that is being applied, as well as an =args= property that holds an array of argument expressions.

The ~>(x, 5)~ part of the previous program would be represented like this:
#+begin_src js
{
  type: "apply",
  operator: {type: "identifier", name: ">"},
  args: [
    {type: "identifier", name: "x"},
    {type: "value", value: 5}
  ]
}
#+end_src

To let us do interesting things in our language, we include a few special forms and useful bindings in the global scope:
+ Special forms: =if=, =while=, =do= to do multiple things in one expression, =define= to create bindings, and =fun= to create functions
+ Global scope: =true=, =false=, =+, -, *, /=, =print= to print to the console

[[./eloquentjs/egg/egg.html][Try out the Egg interpreter!]]

** Arrays
We can implement arrays in Egg by adding the functions =array=, =length=, and =element= to the global scope. Respectively, they initialise an array, compute its length, and retrieve an element by index. Like with =if= and =while=, we cheat and use JavaScript's arrays in our implementation.
#+begin_src js
globalScope.array = (...values) => {
  return [...values];
};

globalScope.length = (array) => {
  return array.length;
};

globalScope.element = (array, n) => {
  return array[n];
};
#+end_src

** Comments
Allowing comments in Egg is a matter of changing the parser so it skips the rest of the line when it encounters a =#=.
#+begin_src js
function skipSpace(string) {
  let skippable = string.match(/^(\s|#.*)*/);
  return string.slice(skippable[0].length);
}
#+end_src

** Fixing scope
Assigning a new value to a binding with =define= can be counterintuitive because it may create a new binding in the local scope instead of updating the desired binding. We can get around this by adding the =set= function which will search for the binding in outer scopes.
#+begin_src js
specialForms.set = (args, scope) => {
  if (args.length != 2 || args[0].type != "identifier") {
    throw new SyntaxError("Incorrect use of set");
  }

  let value = evaluate(args[1], scope);
  let name = args[0].name;

  for (let s = scope; s; s = Object.getPrototypeOf(s)) {
    if (Object.prototype.hasOwnProperty(s, name)) {
      s[name] = value;
      return value;
    }
  }

  throw new ReferenceError(`Could not find ${name} in any scope.`);
};
#+end_src

* Project 3: Platformer game

This project uses the DOM as the rendering backend for a simple 2D platformer. Everything in the game is made of =div= elements with styling and positioning applied.  You can actually get decent performance by adding and removing DOM elements, although working this way can feel a little clunky[fn::A more idiomatic approach is to use the =<canvas>=  element].

[[./eloquentjs/platformer/platformer.html][Try out the platformer game here!]]

** Game over
We can keep track of the player's lives by adding some logic to the function that starts the game.
#+begin_src js
async function runGame(plans, Display) {
  let lives = 3;
  for (let level = 0; level < plans.length; ) {
    console.log(`Lives: ${lives}`);
    let status = await runLevel(new Level(plans[level]), Display);
    if (status == "lost") {
      lives--;
      if (lives == 0) {
        console.log("You lost, restarting the game...");
        level = 0;
        lives = 3;
      }
    }
    if (status == "won") level++;
  }
  console.log("You've won!");
}
#+end_src

** Pausing the game
Adding a way to pause/unpause the game is not immediately obvious since adding another key listener in the section where we listen to user input won't work. The solution is to add the key listener for pausing higher up, putting that logic into the =runLevel= function.
#+begin_src js
function runLevel(level, Display) {
  let display = new Display(document.body, level);
  let state = State.start(level);
  let ending = 1;
  let running = "yes";

  return new Promise((resolve) => {
    function escHandler(event) {
      if (event.key != "Escape") return;
      event.preventDefault();
      if (running == "no") {
        console.log("Unpausing game");
        running = "yes";
        runAnimation(frame);
      } else if (running == "yes") {
        console.log("Pausing game");
        running = "pausing";
      } else {
        running = "yes";
      }
    }

    window.addEventListener("keyup", escHandler);

    let keys = trackKeys(["ArrowLeft", "ArrowRight", "ArrowUp", "a", "d", "w"]);

    function frame(time) {
      if (running == "pausing") {
        console.log("Game paused");
        running = "no";
        return false;
      }

      state = state.update(time, keys);
      display.syncState(state);
      if (state.status == "playing") {
        return true;
      } else if (ending > 0) {
        ending -= time;
        return true;
      } else {
        display.clear();
        window.removeEventListener("keyup", escHandler);
        keys.unregister();
        resolve(state.status);
        return false;
      }
    }

    runAnimation(frame);
  });
}
#+end_src

** TODO A monster
zzz

* Exercise: Game of Life
Using HTML forms, it's possible to write a basic version of the Game of Life. Each generation, a checkbox transitions according to the following rules:
1. Underpopulation: any checked checkbox with less than two checked neighbours becomes unchecked
2. Survival: any checked checkbox with two or three neighbours stays checked in the next generation
3. Overpopulation: any checked checkbox with more than three checked neighbours becomes unchecked
3. Reproduction: any unchecked checkbox with exactly three neighbours becomes checked

Technically, the Game of Life is meant to be played on an infinite grid. There are a few ways to address this, such as wrapping cells around to the other side of the grid in case they go off screen. However, I didn't bother with this -- try to imagine there is a sea of dead cells around the grid.

[[./eloquentjs/game-of-life/game-of-life.html][Try out the Game of Life!]]

* TODO Project 4: Pixel art editor
As discussed in the platformer project, another way to render graphics on the web is using =<canvas>= elements.

[[./eloquentjs/pixel-art/pixel-art.html][Try out the pixel art editor!]]

* TODO Project 5: Skill-sharing website
Need to host this somewhere... need Node to be running to keep store the talks.
